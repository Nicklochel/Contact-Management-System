The contact hash table was chosen for this project due to its ability to provide fast lookups. Unlike lists, which require linear search time (O(n)), a well-implemented hash table allows insertion, search, and deletion operations to be completed in average-case constant time (O(1)), which is critical when managing hundreds of contacts. This efficiency ensures that users can quickly find or update contact information, even on devices with limited memory.
To handle collisions, the hash table employs separate chaining using linked lists. Each index of the underlying array stores either None or a linked list of Node objects, each holding a Contact. When multiple contacts hash to the same index, they are appended to the linked list. If a contact with the same name already exists, the implementation updates its phone number rather than creating a duplicate entry. This method simplifies collision management while maintaining fast lookups and updates.
The hash function converts a contactâ€™s name into an array index by summing the ASCII values of all characters in the name and taking the modulus with the table size. This approach is simple yet effective for distributing entries across the array, reducing clustering and improving performance.
Engineers might choose a hash table over a list when rapid searches or frequent updates are required. Compared to trees, hash tables provide faster average-case performance for exact-match lookups but are less suitable for ordered data queries. This implementation demonstrates how a custom hash table can efficiently store, retrieve, and manage contact information while handling edge cases such as collisions and duplicate keys.
